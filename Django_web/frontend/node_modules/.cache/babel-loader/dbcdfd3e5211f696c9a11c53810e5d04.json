{"ast":null,"code":"var $config = Symbol.for('FluidValue:config');\nexport { hasFluidValue, getFluidValue, getFluidConfig, setFluidConfig, addFluidObserver };\n/** Does the given value have a `FluidConfig` object? */\n\nvar hasFluidValue = function (arg) {\n  return !!getFluidConfig(arg);\n};\n\nfunction getFluidValue(arg) {\n  var config = getFluidConfig(arg);\n  return config ? config.get() : arg;\n}\n\nfunction getFluidConfig(arg) {\n  if (arg) return arg[$config];\n}\n/** Set the methods for observing the given object. */\n\n\nfunction setFluidConfig(target, config) {\n  Object.defineProperty(target, $config, {\n    value: config,\n    configurable: true\n  });\n}\n\nfunction addFluidObserver(target, observer) {\n  var config = getFluidConfig(target);\n\n  if (config) {\n    config.addChild(observer);\n    return function () {\n      return config.removeChild(observer);\n    };\n  }\n}\n/**\n * This class stores a single dynamic value, which can be observed by multiple `FluidObserver` objects.\n *\n * In order to support non-writable streams, this class doesn't expect a `set` method to exist.\n *\n * It can send *any* event to observers, not only change events.\n */\n\n\nvar FluidValue =\n/** @class */\nfunction () {\n  function FluidValue() {\n    setFluidConfig(this, this);\n  }\n\n  return FluidValue;\n}();\n\nexport { FluidValue };","map":{"version":3,"sources":["C:\\Users\\drago\\Documents\\Github Repository VSCode\\DB_end_project\\frontend\\node_modules\\fluids\\src\\index.ts"],"names":[],"mappings":"AAAA,IAAM,OAAO,GAAG,MAAM,CAAC,GAAP,CAAW,mBAAX,CAAhB;AAEA,SACE,aADF,EAEE,aAFF,EAGE,cAHF,EAIE,cAJF,EAKE,gBALF;AAQA;;AACA,IAAM,aAAa,GAAG,UAAC,GAAD,EAAS;AAAwB,SAAA,CAAC,CAAC,cAAc,CAAhB,GAAgB,CAAhB;AAAqB,CAA5E;;AAMA,SAAS,aAAT,CAAuB,GAAvB,EAA+B;AAC7B,MAAM,MAAM,GAAG,cAAc,CAAC,GAAD,CAA7B;AACA,SAAO,MAAM,GAAG,MAAM,CAAC,GAAP,EAAH,GAAkB,GAA/B;AACD;;AAQD,SAAS,cAAT,CAAwB,GAAxB,EAAgC;AAC9B,MAAI,GAAJ,EAAS,OAAO,GAAG,CAAC,OAAD,CAAV;AACV;AAED;;;AACA,SAAS,cAAT,CAAwB,MAAxB,EAAwC,MAAxC,EAA2D;AACzD,EAAA,MAAM,CAAC,cAAP,CAAsB,MAAtB,EAA8B,OAA9B,EAAuC;AACrC,IAAA,KAAK,EAAE,MAD8B;AAErC,IAAA,YAAY,EAAE;AAFuB,GAAvC;AAID;;AAaD,SAAS,gBAAT,CAA0B,MAA1B,EAA0C,QAA1C,EAAiE;AAC/D,MAAM,MAAM,GAAG,cAAc,CAAC,MAAD,CAA7B;;AACA,MAAI,MAAJ,EAAY;AACV,IAAA,MAAM,CAAC,QAAP,CAAgB,QAAhB;AACA,WAAO,YAAA;AAAM,aAAA,MAAO,CAAC,WAAR,CAAA,QAAA,CAAA;AAA6B,KAA1C;AACD;AACF;AAyBD;;;;;;AAMG;;;AACH,IAAA,UAAA;AAAA;AAAA,YAAA;AAEE,WAAA,UAAA,GAAA;AACE,IAAA,cAAc,CAAC,IAAD,EAAO,IAAP,CAAd;AACD;;AAIH,SAAA,UAAA;AAAC,CARD,EAAA","sourcesContent":["const $config = Symbol.for('FluidValue:config')\n\nexport {\n  hasFluidValue,\n  getFluidValue,\n  getFluidConfig,\n  setFluidConfig,\n  addFluidObserver,\n}\n\n/** Does the given value have a `FluidConfig` object? */\nconst hasFluidValue = (arg: any): arg is FluidValue => !!getFluidConfig(arg)\n\n/** Get the current value of a fluid object. Returns the first argument when it's not a fluid object. */\nfunction getFluidValue<T, U = never>(\n  target: T | FluidValue<U>\n): Exclude<T, FluidValue> | U\nfunction getFluidValue(arg: any) {\n  const config = getFluidConfig(arg)\n  return config ? config.get() : arg\n}\n\ntype GetFluidConfig<T> = T extends FluidValue<infer U, infer E>\n  ? FluidConfig<U, E>\n  : FluidConfig | undefined\n\n/** Get the methods for observing the given object. Returns undefined if not a fluid object. */\nfunction getFluidConfig<T>(arg: T): GetFluidConfig<T>\nfunction getFluidConfig(arg: any) {\n  if (arg) return arg[$config]\n}\n\n/** Set the methods for observing the given object. */\nfunction setFluidConfig(target: object, config: FluidConfig) {\n  Object.defineProperty(target, $config, {\n    value: config,\n    configurable: true,\n  })\n}\n\n/** Add an observer to a fluid object. Returns an unsubscribe function if the target is a fluid object, otherwise undefined. */\nfunction addFluidObserver<E extends FluidEvent>(\n  target: FluidValue<any, E>,\n  observer: FluidObserver<E>\n): () => void\n\nfunction addFluidObserver(\n  target: object,\n  observer: FluidObserver\n): (() => void) | undefined\n\nfunction addFluidObserver(target: object, observer: FluidObserver) {\n  const config = getFluidConfig(target)\n  if (config) {\n    config.addChild(observer)\n    return () => config!.removeChild(observer)\n  }\n}\n\nexport interface ChangeEvent<T = any> {\n  type: 'change'\n  parent: FluidValue<T>\n  value: T\n}\n\n/**\n * An event sent to `FluidObserver` objects.\n */\nexport interface FluidEvent<T = any> {\n  type: string\n  parent: FluidValue<T>\n}\n\n/**\n * Compatibility layer for external data sources.\n */\nexport interface FluidConfig<T = any, Event extends FluidEvent<T> = any> {\n  get(): T\n  addChild(child: FluidObserver<Event>): void\n  removeChild(child: FluidObserver<Event>): void\n}\n\n/**\n * This class stores a single dynamic value, which can be observed by multiple `FluidObserver` objects.\n *\n * In order to support non-writable streams, this class doesn't expect a `set` method to exist.\n *\n * It can send *any* event to observers, not only change events.\n */\nexport abstract class FluidValue<T = any, Event extends FluidEvent<T> = any>\n  implements FluidConfig<T, Event> {\n  constructor() {\n    setFluidConfig(this, this)\n  }\n  abstract get(): T\n  abstract addChild(child: FluidObserver<Event>): void\n  abstract removeChild(child: FluidObserver<Event>): void\n}\n\n/**\n * This object can observe any `FluidValue` object that sends compatible events.\n */\nexport interface FluidObserver<Event extends FluidEvent = any> {\n  onParentChange(event: ChangeEvent | Event): void\n}\n\n/**\n * Add the `FluidValue` type to every property.\n */\nexport type FluidProps<T> = T extends object\n  ? { [P in keyof T]: T[P] | FluidValue<Exclude<T[P], void>> }\n  : unknown\n"]},"metadata":{},"sourceType":"module"}